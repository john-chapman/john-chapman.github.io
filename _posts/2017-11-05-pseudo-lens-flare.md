---
layout: post
title: Pseudo Lens Flare
date: 2017-11-05
comments: true
published: true
tags: screen space, lens flare, shader, effect, glsl
---

A few years ago I wrote a [blog post](http://john-chapman-graphics.blogspot.fr/2013/02/pseudo-lens-flare.html) describing a screen space post process for rendering lens flares. I had first read about this idea on Matt Pettineo's blog (1), and apparently it dates back to a GDC2003 presentation given by Masaki Kawase. I mention this because I've seen the technique credited directly to me in a few places online; I didn't invent the idea, but in my original post I did described a few enhancements to improve the quality of the effect. 

This post will be a slightly more up-to-date and terse overview of the technique along with a couple of improvements to the compositing step. There is also a sample implementation LINK.

## Lens Flare ##

Lens flare is a photographic artefact caused by interactions between a lens system and the light passing through it. As with other types of photographic artefacts, it is desirable to recreate in games in order to create a 'cinematic' effect. Along with other effects like bloom, lens flare can also increase perceived brightness.

The classical approach to rendering lens flares is to use sprites.

The screen space technique comprises the following 4 steps:

1. Downsample the scene image.
2. Generate lens flare features.
3. Blur.
4. Upsample/composite.

## Downsample ##

This is very straightforward so I won't describe it in detail. Very likely you'll already have generated a downsampled version of the scene buffer as an input to other post processing effects (bloom, depth of field).

## Feature Generation ##

During this step we read the downsampled scene image in order to generate lens the flare features.

### Ghosts ###

'Ghosts' are the repetitious blobs which mirror bright spots in the source image, pivoting around the image center. These can be generated by sampling along a vector which passes through the image center:

DIAGRAM: Ghosts with vectors.

{% highlight glsl %}
vec3 ret = vec3(0.0);
vec2 ghostVec = (vec2(0.5) - uv) * uGhostSpacing;	
for (int i = 0; i < uGhostCount; ++i) {
	vec2 suv = fract(uv + ghostVec * vec2(i));
	
	float d = length(vec2(0.5) - suv) / length(vec2(0.5));
	float weight = 1.0 - smoothstep(0.0, 0.75, d); // reduce contributions from samples at the screen edge
	
	vec3 s = SampleSceneColor(suv);
	s = ApplyThreshold(s, uGhostThreshold);
	
	ret += s * weight;
}
{% endhighlight %}

`ApplyThreshold()` is a function to isolate bright areas in the source image. A very simple implementation is as follows:

{% highlight glsl %}
vec3 ApplyThreshold(in vec3 _rgb, in float _threshold)
{
	return max(_rgb - vec3(_threshold), vec3(0.0));
}
{% endhighlight %}

The samples are weighted to fade out ghosts for bright spots near the edge of the source image. 

We can also modulate the color of the samples according to a 1d gradient, sampled based on the distance to the image center (`d` in the code above). This can be applied globally or per-sample, the latter providing better results:

DIAGRAM: Global vs. per-sample.

### Halos ###

{% highlight glsl %}
{% endhighlight %}

![Thread-wise list partitioning](/images/list_threadwise.png)

## References ##

1. [More Post-Processing Tricks: Lens Flare](https://mynameismjp.wordpress.com/2009/12/15/more-post-processing-tricks-lens-flare/) (Matt Pettineo)
2. Frame Buffer Post Processing Effects in DOUBLE S.T.E.A.L (Masaki Kawase)