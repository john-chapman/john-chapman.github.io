---
layout: post
title: Pseudo Lens Flare
date: 2017-11-05
comments: true
published: true
tags: screen space, lens flare, shader, effect, glsl
---

A few years ago I wrote a [blog post](http://john-chapman-graphics.blogspot.fr/2013/02/pseudo-lens-flare.html) describing a screen space post process for rendering lens flares. I had first read about this idea on Matt Pettineo's blog (1), but the basic technique dates back to a GDC2003 presentation given by Masaki Kawase (2). I mention this because I've seen the technique credited directly to me in a few places online; I didn't invent the idea, but in my original post I did described a few enhancements to improve the quality of the effect.

This post will be a slightly more up-to-date and terse overview of the technique along with a couple of improvements to the compositing step. There is also a sample implementation where you can refer to the final shader code \LINK.

## Lens Flare ##

Lens flare is a photographic artefact caused by reflections within a lens system. As with other types of photographic artefacts, it is desirable to recreate in games or CGI in order to create a 'cinematic' effect. Along with other effects like bloom, lens flare can also increase perceived brightness.

The 'classical' approach to rendering lens flares is to draw a few sprites, using some occlusion data to decide how bright the overall effect is:

\IMAGE Sprite-based lens flare.

The downside of this technique is that it requires explicit placement of lens flares. By using the rendered image to directly drive the lens flare effect we

The screen space technique comprises the following 4 steps:

1. Downsample the scene image.
2. Generate lens flare features.
3. Blur.
4. Upsample/composite.

## Downsample ##

This is very straightforward so I won't describe it in detail. Very likely you'll have already generated a downsampled version of the scene buffer as an input to other post processing effects (bloom, depth of field). Choosing the downsampled size is a tradeoff: smaller render targets make the feature generation and blur steps cheaper, however you may need more blur to hide blocky artefacts if the resolution is too low. A nice middle ground might be to use a bicubic filter during the downsampling to provide a smoother input to the feature generation step.

## Feature Generation ##

Here we read the downsampled scene image in order to generate lens the flare 'features'. Bright areas in the source image should 'project' light to other areas of the image along a path through the image centre.

### Ghosts ###

'Ghosts' are the repeating blobs which mirror bright spots in the source image, pivoting around the image center. These can be generated by sampling along a vector which passes through the image center:

\IMAGE Ghosts + sampling vectors.

The number of samples and sample spacing can be exposed as artist-settable parameters.

{% highlight glsl %}
vec2 uv = vec2(1.0) - vUv; // flip the texture coordinates
vec3 ret = vec3(0.0);
vec2 ghostVec = (vec2(0.5) - uv) * uGhostSpacing;
for (int i = 0; i < uGhostCount; ++i) {
	vec2 suv = fract(uv + ghostVec * vec2(i));

	float d = length(vec2(0.5) - suv) / length(vec2(0.5));
	float weight = 1.0 - smoothstep(0.0, 0.75, d); // reduce contributions from samples at the screen edge

	vec3 s = SampleSceneColor(suv);
	s = ApplyThreshold(s, uGhostThreshold);

	ret += s * weight;
}
{% endhighlight %}

`ApplyThreshold()` is a function to isolate bright areas in the source image. A very simple implementation is as follows:

{% highlight glsl %}
vec3 ApplyThreshold(in vec3 _rgb, in float _threshold)
{
	return max(_rgb - vec3(_threshold), vec3(0.0));
}
{% endhighlight %}

The samples are weighted to fade out ghosts for bright spots near the edge of the source image.

We can also modulate the color of the samples according to a 1d gradient, sampled based on the distance to the image center (`d` in the code above). This can be applied globally or per-sample, the latter providing better results:

\IMAGE: Global vs. per-sample.

### Halos ###

If we take a vector to the centre of the image, as for the ghost sampling, but fix the vector length, we get a different effect: the source image is warped:

\IMAGE: Warped image.

We can use this to produce a 'halo' feature, weighting the sample to restrict the contribution of the warped image to a ring. The radius and aspect ratio can be exposed to control the effect:

\IMAGE: Halo weight * warped image = halo.

### Chromatic Aberration ###

Cheaper to do at the feature stage (ultimately use fewer samples).

## Blur ##

After feature generation, we're left with something like this:

\IMAGE: Features without blur

Aside from the blocky artefacts from the downsampling, there's also the problem of the ghosts maintaining the shape of the source image. A liberal amount of blur addresses both issues:

\IMAGE: Features with blur

The quality of the blur can be reduced to improve performance, depending on how the lens flare is applied to the final image.

## Upsample/Composite ##

### Lens Dirt ###

### Starburst ###

## Conclusion ##

## References ##

1. [More Post-Processing Tricks: Lens Flare](https://mynameismjp.wordpress.com/2009/12/15/more-post-processing-tricks-lens-flare/) (Matt Pettineo)
2. Frame Buffer Post Processing Effects in DOUBLE S.T.E.A.L (Masaki Kawase)
